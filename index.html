<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Paint</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            padding: 30px;
            max-width: 1400px;
            width: 100%;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .toolbar {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 15px;
        }

        .tool-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 10px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        label {
            font-weight: 600;
            color: #555;
        }

        input[type="color"] {
            width: 60px;
            height: 40px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }

        input[type="color"]:hover {
            transform: scale(1.1);
        }

        input[type="range"] {
            width: 120px;
        }

        input[type="text"] {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }

        button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        .canvas-container {
            position: relative;
            display: inline-block;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            background: white;
        }

        canvas {
            display: block;
            cursor: crosshair;
            background: white;
        }

        .cursors-overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 10;
        }

        .remote-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: none;
            transition: left 0.1s, top 0.1s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }

        .remote-cursor::after {
            content: attr(data-name);
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
        }

        .active-users {
            margin-top: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            text-align: center;
        }

        .active-users h3 {
            color: #333;
            margin-bottom: 10px;
        }

        .user-list {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .user-badge {
            display: inline-flex;
            align-items: center;
            gap: 5px;
            padding: 8px 15px;
            background: white;
            border-radius: 20px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .user-badge-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 3px rgba(0, 0, 0, 0.3);
        }

        .status {
            text-align: center;
            margin-top: 15px;
            padding: 10px;
            background: #e3f2fd;
            border-radius: 8px;
            color: #1976d2;
            font-weight: 500;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.8em;
            }

            .toolbar {
                padding: 15px;
            }

            canvas {
                max-width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸŽ¨ Multiplayer Paint</h1>
        
        <div class="toolbar">
            <div class="tool-group">
                <label for="username">Your Name:</label>
                <input type="text" id="username" placeholder="Enter your name" value="Artist">
            </div>
            
            <div class="tool-group">
                <label for="color">Color:</label>
                <input type="color" id="color" value="#000000">
            </div>
            
            <div class="tool-group">
                <label for="size">Size:</label>
                <input type="range" id="size" min="1" max="50" value="5">
                <span id="sizeValue">5</span>
            </div>
            
            <div class="tool-group">
                <button id="clearBtn">Clear Canvas</button>
            </div>
        </div>

        <div style="text-align: center;">
            <div class="canvas-container">
                <canvas id="canvas" width="1200" height="800"></canvas>
                <div class="cursors-overlay" id="cursorsOverlay"></div>
            </div>
        </div>

        <div class="active-users">
            <h3>ðŸ‘¥ Active Artists</h3>
            <div class="user-list" id="userList"></div>
        </div>

        <div class="status" id="status">Connecting to server...</div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        // Supabase configuration
        const SUPABASE_URL = 'https://hhfvoadudcikgpygexvf.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhoZnZvYWR1ZGNpa2dweWdleHZmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk3ODM1NjMsImV4cCI6MjA3NTM1OTU2M30.SMhoGC3ylyA2Q0blvJP62eu5a3MHK_k1PL8viQ0iwdw';

        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const colorInput = document.getElementById('color');
        const sizeInput = document.getElementById('size');
        const sizeValue = document.getElementById('sizeValue');
        const usernameInput = document.getElementById('username');
        const clearBtn = document.getElementById('clearBtn');
        const statusDiv = document.getElementById('status');
        const cursorsOverlay = document.getElementById('cursorsOverlay');
        const userListDiv = document.getElementById('userList');

        let isDrawing = false;
        let currentStroke = [];
        let userId = Math.random().toString(36).substring(7);
        let canvasId = null;
        let remoteCursors = {};
        let activeUsers = {};

        // Update size display
        sizeInput.addEventListener('input', () => {
            sizeValue.textContent = sizeInput.value;
        });

        // Initialize
        async function init() {
            try {
                // Get the default canvas
                const { data: canvases, error } = await supabase
                    .from('canvases')
                    .select('*')
                    .limit(1)
                    .single();

                if (error) throw error;
                canvasId = canvases.id;

                // Load existing strokes
                await loadStrokes();

                // Subscribe to new strokes
                subscribeToStrokes();

                // Subscribe to active users
                subscribeToActiveUsers();

                // Update user presence
                await updatePresence();
                setInterval(updatePresence, 5000);

                // Clean up inactive users
                setInterval(cleanupInactiveUsers, 10000);

                updateStatus('Connected! Start painting!', false);
            } catch (error) {
                console.error('Initialization error:', error);
                updateStatus('Error connecting to server', true);
            }
        }

        // Load existing strokes
        async function loadStrokes() {
            const { data: strokes, error } = await supabase
                .from('strokes')
                .select('*')
                .eq('canvas_id', canvasId)
                .order('created_at', { ascending: true });

            if (!error && strokes) {
                strokes.forEach(stroke => {
                    drawStroke(stroke.points, stroke.color, stroke.size);
                });
            }
        }

        // Subscribe to new strokes
        function subscribeToStrokes() {
            supabase
                .channel('strokes')
                .on('postgres_changes', 
                    { event: 'INSERT', schema: 'public', table: 'strokes', filter: `canvas_id=eq.${canvasId}` },
                    (payload) => {
                        if (payload.new.user_id !== userId) {
                            drawStroke(payload.new.points, payload.new.color, payload.new.size);
                        }
                    }
                )
                .subscribe();
        }

        // Subscribe to active users
        function subscribeToActiveUsers() {
            supabase
                .channel('active_users')
                .on('postgres_changes',
                    { event: '*', schema: 'public', table: 'active_users', filter: `canvas_id=eq.${canvasId}` },
                    (payload) => {
                        if (payload.eventType === 'DELETE') {
                            removeUser(payload.old.user_id);
                        } else {
                            updateUser(payload.new);
                        }
                    }
                )
                .subscribe();

            // Load initial users
            loadActiveUsers();
        }

        // Load active users
        async function loadActiveUsers() {
            const { data: users, error } = await supabase
                .from('active_users')
                .select('*')
                .eq('canvas_id', canvasId);

            if (!error && users) {
                users.forEach(user => {
                    if (user.user_id !== userId) {
                        updateUser(user);
                    }
                });
            }
        }

        // Update user in UI
        function updateUser(user) {
            if (user.user_id === userId) return;

            activeUsers[user.user_id] = user;

            // Update cursor
            let cursor = remoteCursors[user.user_id];
            if (!cursor) {
                cursor = document.createElement('div');
                cursor.className = 'remote-cursor';
                cursor.setAttribute('data-name', user.user_name);
                cursorsOverlay.appendChild(cursor);
                remoteCursors[user.user_id] = cursor;
            }

            cursor.style.backgroundColor = user.color;
            cursor.style.left = user.cursor_x + 'px';
            cursor.style.top = user.cursor_y + 'px';
            cursor.setAttribute('data-name', user.user_name);

            updateUserList();
        }

        // Remove user
        function removeUser(userIdToRemove) {
            if (remoteCursors[userIdToRemove]) {
                remoteCursors[userIdToRemove].remove();
                delete remoteCursors[userIdToRemove];
            }
            delete activeUsers[userIdToRemove];
            updateUserList();
        }

        // Update user list display
        function updateUserList() {
            const allUsers = [
                { user_id: userId, user_name: usernameInput.value, color: colorInput.value },
                ...Object.values(activeUsers)
            ];

            userListDiv.innerHTML = allUsers.map(user => `
                <div class="user-badge">
                    <div class="user-badge-color" style="background-color: ${user.color}"></div>
                    <span>${user.user_name}</span>
                </div>
            `).join('');
        }

        // Update presence
        async function updatePresence(x = 0, y = 0) {
            await supabase
                .from('active_users')
                .upsert({
                    canvas_id: canvasId,
                    user_id: userId,
                    user_name: usernameInput.value,
                    cursor_x: x,
                    cursor_y: y,
                    color: colorInput.value,
                    last_seen: new Date().toISOString()
                });
            
            updateUserList();
        }

        // Clean up inactive users
        async function cleanupInactiveUsers() {
            const cutoff = new Date(Date.now() - 15000).toISOString();
            await supabase
                .from('active_users')
                .delete()
                .eq('canvas_id', canvasId)
                .lt('last_seen', cutoff);
        }

        // Drawing functions
        function startDrawing(e) {
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            currentStroke = [{ x, y }];
            
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        function draw(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Update cursor position
            updatePresence(x, y);

            if (!isDrawing) return;

            currentStroke.push({ x, y });
            
            ctx.lineTo(x, y);
            ctx.strokeStyle = colorInput.value;
            ctx.lineWidth = sizeInput.value;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        async function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;

            if (currentStroke.length > 0) {
                // Save stroke to database
                await supabase.from('strokes').insert({
                    canvas_id: canvasId,
                    user_id: userId,
                    color: colorInput.value,
                    size: parseInt(sizeInput.value),
                    points: currentStroke
                });
            }

            currentStroke = [];
        }

        function drawStroke(points, color, size) {
            if (points.length === 0) return;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);
            
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            
            ctx.strokeStyle = color;
            ctx.lineWidth = size;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.stroke();
        }

        async function clearCanvas() {
            if (confirm('Clear the entire canvas? This will affect all users!')) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                await supabase
                    .from('strokes')
                    .delete()
                    .eq('canvas_id', canvasId);
            }
        }

        function updateStatus(message, isError = false) {
            statusDiv.textContent = message;
            statusDiv.className = isError ? 'status error' : 'status';
        }

        // Event listeners
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseleave', stopDrawing);

        clearBtn.addEventListener('click', clearCanvas);

        usernameInput.addEventListener('change', () => {
            updatePresence();
        });

        // Touch support for mobile
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', async () => {
            await supabase
                .from('active_users')
                .delete()
                .eq('canvas_id', canvasId)
                .eq('user_id', userId);
        });

        // Start the app
        init();
    </script>
</body>
</html>